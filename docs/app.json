[{"name": "app.py", "content": "# Shiny app for Risk board game probability data\nfrom shiny import App, Inputs, Outputs, Session, reactive, render, ui\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport RiskProbabilitiesLib as rpl\nimport RiskGenerateProbs as rgp\n\ndie_size = 6 # Number of sides on the die\nprobs = rgp.generate_probabilities(die=die_size, filename='', save_file=False)\n# Move these to server logic later to allow users to change die size\n\napp_ui = ui.page_fluid(\n    ui.layout_columns(\n        ui.card(\n            ui.input_slider('chart_size', 'Chart Size', min=1, max=30, value=10),\n            ui.input_selectize('die_size', 'Number of Faces on Die', choices=[4, 6, 8, 12, 20], selected=6),\n            ui.output_plot('plot_probs'),\n        ),\n        ui.card(\n            ui.input_slider('num_att', 'Number of Attackers', min=1, max=30, value=1),\n            ui.input_slider('num_def', 'Number of Defenders', min=1, max=30, value=1),\n            ui.output_text('selected_probability'),\n        ),\n    )\n)\n\ndef server(input: Inputs, output: Outputs, session: Session):\n    # builds the probability chart for the chosen slider value and die size\n    # called both to display chart and for the single battle probability\n    @reactive.calc\n    def prob_chart():\n        die_size = int(input.die_size()) # Number of sides on the die\n        probs = rgp.generate_probabilities(die=die_size, filename='', save_file=False)\n\n        #chart_size = input.chart_size()\n        # loads a larger chart in the background, not necessarily all displayed\n        chart_size = 30\n        chart = np.zeros([chart_size+1, chart_size+1])\n\n        # initialize a 100% chance of the attackers winning with 0 defenders\n        for i in range(chart_size+1):\n            chart[i,0] = 1\n\n        # fill in the case where there is 1 attacker and 1 defender\n        chart[1,1] = probs[0,0,0]\n\n        # fill in the cases with 2 attackers OR 2 defenders\n        for i in range(2,chart_size+1):\n            [p0,p1,p2] = rpl.get_probs(i,1,probs)\n            chart[i,1] = p0*chart[i,0] + p1*chart[i-1,1] # first term should be p0\n            [p0,p1,p2] = rpl.get_probs(1,i,probs)\n            chart[1,i] = p0*chart[1,i-1] + p1*chart[0,i] # second term should be 0\n        \n        # fill in the rest of the chart\n        for m in range(2,chart_size+1):\n            [p0,p1,p2] = rpl.get_probs(m,m,probs)\n            chart[m,m] = p0*chart[m,m-2] + p1*chart[m-1,m-1] + p2*chart[m-2,m]\n            for i in range(m+1,chart_size+1):\n                [p0,p1,p2] = rpl.get_probs(i,m,probs)\n                chart[i,m] = p0*chart[i,m-2] + p1*chart[i-1,m-1] + p2*chart[i-2,m]\n                [p0,p1,p2] = rpl.get_probs(m,i,probs)\n                chart[m,i] = p0*chart[m,i-2] + p1*chart[m-1,i-1] + p2*chart[m-2,i]\n        \n        return chart\n\n    @render.plot\n    def plot_probs():\n        # logic that was here is now in update_chart_data\n        chart_size = input.chart_size()\n        chart = prob_chart()\n\n        ch = plt.imshow(chart[1:chart_size+1,1:chart_size+1], cmap='Reds',origin='lower',extent=(0.5,chart_size+0.5,0.5,chart_size+0.5))\n        ticks = [i for i in range(1,chart_size+1)]\n        plt.xticks(ticks)\n        plt.yticks(ticks)\n        plt.xlabel('Defending Army Size')\n        plt.ylabel('Attacking Army Size')\n\n        # Is there a way to refine this based on window size?\n        annotate_plot = True\n        if chart_size <= 11:\n            font_size_str = 'small'\n        elif chart_size <= 14:\n            font_size_str = 'x-small'\n        elif chart_size <= 18:\n            font_size_str = 'xx-small'\n        else:\n            annotate_plot = False\n        \n        if annotate_plot:\n            for i in range(1,chart_size+1):\n                for j in range(1,chart_size+1):\n                    p = chart[i,j]\n                    if p >= 0.995:\n                        p_str = '>.99'\n                    elif p< 0.005:\n                        p_str = '<.01'\n                    else:\n                        p_str = f'{p:.2f}'\n                    if p>0.5:\n                        c_str = 'white'\n                    else:\n                        c_str = 'black'\n                    plt.annotate(p_str, xy=(j,i), ha='center', va='center', color=c_str, fontsize = font_size_str)\n    \n    @render.text\n    def selected_probability():\n        chart = prob_chart()\n        if input.num_att() == 1:\n            attacker_str = 'attacker'\n        else:\n            attacker_str = 'attackers'\n        if input.num_def() == 1:\n            defender_str = 'defender'\n        else:\n            defender_str = 'defenders'\n        p = chart[input.num_att(),input.num_def()]\n        if p>0.99995:\n            p_str = '>99.99%'\n        elif p<0.00005:\n            p_str = '<0.01%'\n        else:\n            p_str = f'{p:.2%}'\n        return f'Chance of {input.num_att()} {attacker_str} defeating {input.num_def()} {defender_str}: {p_str}'\n\napp = App(app_ui, server)", "type": "text"}, {"name": "RiskGenerateProbs.py", "content": "# Generates a numpy file with the probabilities used in Risk visualizations\n\nimport numpy as np\nimport RiskProbabilitiesLib as rpl\n\ndef generate_probabilities(die, filename, save_file):\n\t# generate probabilities\n\t# build pre-sorted dictionaries for one, two, and three dice\n\tfor p in range(die):\n\t\tif p == 0:\n\t\t\tone_dict = { p: [p+1] }\n\t\telse:\n\t\t\tone_dict[p] = [p+1]\n\t\tfor q in range(die):\n\t\t\ttwo_dict_index = die*p+q\n\t\t\ttwo_dict_entry = sorted([p+1,q+1],reverse=True)\n\t\t\tif two_dict_index == 0:\n\t\t\t\ttwo_dict = { two_dict_index: two_dict_entry }\n\t\t\telse:\n\t\t\t\ttwo_dict[two_dict_index] = two_dict_entry\n\t\t\tfor r in range(die):\n\t\t\t\tthree_dict_index = die*die*p+die*q+r\n\t\t\t\tthree_dict_entry = sorted([p+1,q+1,r+1],reverse=True)\n\t\t\t\tif three_dict_index == 0:\n\t\t\t\t\tthree_dict = { three_dict_index: three_dict_entry }\n\t\t\t\telse:\n\t\t\t\t\tthree_dict[three_dict_index] = three_dict_entry\n\t\n\tdict_key = { 1:one_dict, 2:two_dict, 3:three_dict}\n\tprobs = np.zeros([3,2,3])\n\tresults = np.zeros([3,2,3])\n\t\n\t# might be able to make a dictionary of dictionaries to make this code better\n\tfor ai in range(3):\n\t\ta_dice = ai + 1\n\t\ta_dict = dict_key[a_dice]\n\t\tfor di in range(2):\n\t\t\td_dice = di + 1\n\t\t\td_dict = dict_key[d_dice]\n\t\t\ta_combs = die**a_dice\n\t\t\td_combs = die**d_dice\n\t\t\tfor a in range(a_combs):\n\t\t\t\tfor d in range(d_combs):\n\t\t\t\t\t[a_loss,d_loss] = rpl.compare_dice(a_dict[a],d_dict[d])\n\t\t\t\t\tresults[ai][di][a_loss] += 1\n\t\t\tprobs[ai][di] = results[ai][di]/(a_combs*d_combs)\n\t\n\t# save probabilities to numpy file\n\tif save_file:\n\t\tnp.save(filename, probs)\n\treturn probs", "type": "text"}, {"name": "RiskProbabilities.py", "content": "# Calculating probabilities of results of die rolls from the board game Risk\n\n# Attacker rolls up to 3 dice\n# Defender rolls up to 2 dice\n# Highest rolls from each are compared\n# Defender wins ties\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport RiskProbabilitiesLib as rpl\nimport RiskGenerateProbs as rgp\nimport os\n\ndie = 8 # number of faces on each die, 6 in standard game\n\n### BEGINNING OF LOGIC COPIED TO RiskGenerateProbs.py\n# use a try-catch to see if the probabilities already exist for the given die size\nfilename = 'Risk-Probabilities-'+str(die)+'-Sided-Dice.npy'\nif os.path.exists(filename):\n\tprobs = np.load(filename)\n\t# add try-catch here to make sure it's a valid file\nelse:\n\t# generate probabilities\n\t# build pre-sorted dictionaries for one, two, and three dice\n\tprobs = rgp.generate_probabilities(die, filename)\n\nchart_size = 30\nchart = np.zeros([chart_size,chart_size])\n## dimension 1 is number of attackers, dimension 2 is number of defenders\n\n## initializing a 100% chance of the attackers winning if there are 0 defenders\nfor ii in range(1,chart_size):\n\tchart[ii][0] = 1\n\n## filling in the case where there is 1 attacker and 1 defender\nchart[1][1] = probs[0][0][0]\nfor ii in range(2,chart_size):\n\t[p0,p1,p2] = rpl.get_probs(ii,1,probs)\n\tchart[ii][1] = p0*chart[ii][0] + p1*chart[ii-1][1] #second term should be 0\n\t[p0,p1,p2] = rpl.get_probs(1,ii,probs)\n\tchart[1][ii] = p0*chart[1][ii-1] + p1*chart[0][ii] #first term should be 0\nfor m in range(2,chart_size):\n\t[p0,p1,p2] = rpl.get_probs(m,m,probs)\n\tchart[m][m] = p0*chart[m][m-2] + p1*chart[m-1][m-1] + p2*chart[m-2][m]\n\tfor ii in range(m+1,chart_size):\n\t\t[p0,p1,p2] = rpl.get_probs(ii,m,probs)\n\t\tchart[ii][m] = (p0*chart[ii][m-2]) + (p1*chart[ii-1][m-1]) + (p2*chart[ii-2][m])\n\t\t[p0,p1,p2] = rpl.get_probs(m,ii,probs)\n\t\tchart[m][ii] = p0*chart[m][ii-2] + p1*chart[m-1][ii-1] + p2*chart[m-2][ii]\n\nch = plt.imshow(chart[1:chart_size,1:chart_size],cmap = 'Reds',origin='lower',extent=(0.5,chart_size-0.5,0.5,chart_size-0.5))\nticks = [i for i in range(1,chart_size)]\nplt.xticks(ticks)\nplt.yticks(ticks)\nplt.xlabel(\"Defending Army Size\")\nplt.ylabel(\"Attacking Army Size\")\nplt.title(\"Probability of winning an attack in the board game Risk\")\n\nannotate_plot = True\nif chart_size <= 11:\n\tfont_size_str = 'medium'\nelif chart_size <= 16:\n\tfont_size_str = 'small'\nelif chart_size <= 21:\n\tfont_size_str = 'x-small'\nelif chart_size <= 31:\n\tfont_size_str = 'xx-small'\nelse:\n\tannotate_plot = False\n\nif annotate_plot:\n\tfor ii in range(1,chart_size):\n\t\tfor jj in range(1,chart_size):\n\t\t\tp = chart[ii][jj]\n\t\t\tif p >= 0.995:\n\t\t\t\tp_str = '>.99'\n\t\t\telif p < 0.005:\n\t\t\t\tp_str = '<.01'\n\t\t\telse:\n\t\t\t\tp_str = str(\"%.2f\" % chart[ii][jj])\n\t\t\tif p > 0.5:\n\t\t\t\tc_str = 'white'\n\t\t\telse:\n\t\t\t\tc_str = 'black'\n\t\t\tplt.annotate(p_str, xy=(jj,ii), ha='center', va='center', color=c_str, fontsize = font_size_str)\n\nplt.show()", "type": "text"}, {"name": "RiskProbabilitiesLib.py", "content": "## Library of helper functions for RiskProbabilities.py\n\n# requires lists to be sorted already\ndef compare_dice(att_dice,def_dice):\n\tatt_len = len(att_dice)\n\tdef_len = len(def_dice)\n\tcomps = min(att_len,def_len)\n\tatt_loss = 0\n\tdef_loss = 0\n\tfor ii in range(comps):\n\t\tif att_dice[ii] > def_dice[ii]:\n\t\t\tdef_loss += 1\n\t\telse:\n\t\t\tatt_loss += 1\n\treturn [att_loss,def_loss]\n\n# should only be called from select_dice_index(n_att,n_def)\ndef select_dice(n_att,n_def):\n\tif n_att > 3:\n\t\tatt_dice = 3\n\telse:\n\t\tatt_dice = n_att\n\tif n_def > 2:\n\t\tdef_dice = 2\n\telse:\n\t\tdef_dice = n_def\n\treturn [att_dice,def_dice]\n\ndef select_dice_index(n_att,n_def):\n\t[att_dice,def_dice] = select_dice(n_att,n_def)\n\treturn [att_dice-1,def_dice-1]\n\ndef get_probs(n_att,n_def,probs):\n\t[a,d] = select_dice_index(n_att,n_def)\n\treturn probs[a,d]", "type": "text"}]